name: Daily Report to Notion

on:
  schedule:
    # Îß§Ïùº Ïò§Ï†Ñ 9Ïãú (KST) = Îß§Ïùº Ïò§Ï†Ñ 0Ïãú (UTC)
    - cron: '0 0 * * *'
  workflow_dispatch: # ÏàòÎèô Ïã§Ìñâ Í∞ÄÎä•

jobs:
  generate-daily-report:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Create daily report script
        run: |
          cat > daily-report.js << 'EOF'
          const https = require('https');

          // ========== Utility Functions ==========
          
          async function makeRequest(options, postData) {
            return new Promise((resolve, reject) => {
              const req = https.request(options, (res) => {
                let data = '';
                res.on('data', (chunk) => data += chunk);
                res.on('end', () => {
                  try {
                    resolve(JSON.parse(data));
                  } catch (e) {
                    resolve(data);
                  }
                });
              });
              req.on('error', reject);
              if (postData) req.write(postData);
              req.end();
            });
          }

          function getKSTDate() {
            const now = new Date();
            const kst = new Date(now.getTime() + (9 * 60 * 60 * 1000));
            return kst;
          }

          function formatDateForTitle() {
            const date = getKSTDate();
            const yy = String(date.getFullYear()).slice(2);
            const mm = String(date.getMonth() + 1).padStart(2, '0');
            const dd = String(date.getDate()).padStart(2, '0');
            return `${yy}.${mm}.${dd}`;
          }

          function get24HoursAgo() {
            const now = new Date();
            const yesterday = new Date(now.getTime() - (24 * 60 * 60 * 1000));
            return yesterday.toISOString();
          }

          // ========== GitHub API Functions ==========

          async function fetchIssuesWithActivity(owner, repo, token) {
            const since = get24HoursAgo();
            
            const options = {
              hostname: 'api.github.com',
              path: `/repos/${owner}/${repo}/issues?state=all&since=${since}&per_page=100`,
              method: 'GET',
              headers: {
                'User-Agent': 'GitHub-Actions',
                'Authorization': `token ${token}`,
                'Accept': 'application/vnd.github.v3+json'
              }
            };

            const issues = await makeRequest(options);
            
            // Pull Request Ï†úÏô∏
            return issues.filter(issue => !issue.pull_request);
          }

          async function fetchIssueEvents(owner, repo, issueNumber, token) {
            const options = {
              hostname: 'api.github.com',
              path: `/repos/${owner}/${repo}/issues/${issueNumber}/events`,
              method: 'GET',
              headers: {
                'User-Agent': 'GitHub-Actions',
                'Authorization': `token ${token}`,
                'Accept': 'application/vnd.github.v3+json'
              }
            };

            return await makeRequest(options);
          }

          async function fetchIssueComments(owner, repo, issueNumber, token) {
            const since = get24HoursAgo();
            
            const options = {
              hostname: 'api.github.com',
              path: `/repos/${owner}/${repo}/issues/${issueNumber}/comments?since=${since}`,
              method: 'GET',
              headers: {
                'User-Agent': 'GitHub-Actions',
                'Authorization': `token ${token}`,
                'Accept': 'application/vnd.github.v3+json'
              }
            };

            return await makeRequest(options);
          }

          // ========== Issue Categorization ==========

          async function categorizeIssues(issues, owner, repo, token) {
            const since = new Date(get24HoursAgo());
            
            const categorized = {
              completed: [],
              new: [],
              updated: [],
              discussed: []
            };

            for (const issue of issues) {
              const createdAt = new Date(issue.created_at);
              const updatedAt = new Date(issue.updated_at);
              const closedAt = issue.closed_at ? new Date(issue.closed_at) : null;

              // ÏôÑÎ£åÎêú Ïù¥Ïäà
              if (issue.state === 'closed' && closedAt && closedAt > since) {
                categorized.completed.push(issue);
              }
              // ÏÉàÎ°ú ÏÉùÏÑ±Îêú Ïù¥Ïäà
              else if (createdAt > since) {
                categorized.new.push(issue);
              }
              // ÏóÖÎç∞Ïù¥Ìä∏Îêú Ïù¥Ïäà
              else if (updatedAt > since && issue.state === 'open') {
                // ÎåìÍ∏Ä ÌôïÏù∏
                const comments = await fetchIssueComments(owner, repo, issue.number, token);
                
                if (comments.length > 0) {
                  categorized.discussed.push({
                    ...issue,
                    recent_comments_count: comments.length
                  });
                } else {
                  categorized.updated.push(issue);
                }
              }
            }

            return categorized;
          }

          // ========== Gemini API Functions ==========

          async function generateSummaryWithGemini(categorized) {
            const apiKey = process.env.GEMINI_API_KEY;
            
            const prompt = `Îã§ÏùåÏùÄ GitHub ÌîÑÎ°úÏ†ùÌä∏Ïùò ÏßÄÎÇú 24ÏãúÍ∞Ñ ÎèôÏïàÏùò ÌôúÎèô ÎÇ¥Ïó≠ÏûÖÎãàÎã§. 
Ï†ÑÏ≤¥Ï†ÅÏù∏ ÏßÑÌñâ ÏÉÅÌô©ÏùÑ 3-4Î¨∏Îã®ÏúºÎ°ú ÏöîÏïΩÌï¥Ï£ºÏÑ∏Ïöî. ÏôÑÎ£åÎêú ÏûëÏóÖ, ÏÉàÎ°úÏö¥ Ïù¥Ïäà, ÏßÑÌñâ Ï§ëÏù∏ ÏûëÏóÖÏùÑ Ï§ëÏã¨ÏúºÎ°ú ÏûëÏÑ±Ìï¥Ï£ºÏÑ∏Ïöî.

## ÏôÑÎ£åÎêú Ïù¥Ïäà (${categorized.completed.length}Í±¥)
${categorized.completed.map(issue => `- [#${issue.number}] ${issue.title}`).join('\n')}

## ÏÉàÎ°ú ÏÉùÏÑ±Îêú Ïù¥Ïäà (${categorized.new.length}Í±¥)
${categorized.new.map(issue => `- [#${issue.number}] ${issue.title}`).join('\n')}

## ÏóÖÎç∞Ïù¥Ìä∏Îêú Ïù¥Ïäà (${categorized.updated.length}Í±¥)
${categorized.updated.map(issue => `- [#${issue.number}] ${issue.title}`).join('\n')}

## ÌôúÎ∞úÌïú ÎÖºÏùò (${categorized.discussed.length}Í±¥)
${categorized.discussed.map(issue => `- [#${issue.number}] ${issue.title} (ÎåìÍ∏Ä ${issue.recent_comments_count}Í∞ú)`).join('\n')}

ÏöîÏïΩ:`;

            const options = {
              hostname: 'generativelanguage.googleapis.com',
              path: `/v1beta/models/gemini-pro:generateContent?key=${apiKey}`,
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              }
            };

            const requestBody = JSON.stringify({
              contents: [{
                parts: [{
                  text: prompt
                }]
              }]
            });

            try {
              const response = await makeRequest(options, requestBody);
              
              if (response.candidates && response.candidates[0]) {
                return response.candidates[0].content.parts[0].text.trim();
              }
              
              return 'Ïò§ÎäòÏùò ÌôúÎèôÏùÑ ÏöîÏïΩÌï† Ïàò ÏóÜÏäµÎãàÎã§.';
            } catch (error) {
              console.error('Gemini API Error:', error);
              return 'ÏöîÏïΩ ÏÉùÏÑ± Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.';
            }
          }

          // ========== Notion API Functions ==========

          async function createNotionPage(title, content, categorized, repoUrl) {
            const token = process.env.NOTION_TOKEN;
            
            // Notion ÌéòÏù¥ÏßÄ ÎÇ¥Ïö© Íµ¨ÏÑ±
            const children = [];
            
            // ÏöîÏïΩ ÏÑπÏÖò
            children.push({
              object: 'block',
              type: 'heading_2',
              heading_2: {
                rich_text: [{ type: 'text', text: { content: 'üìä Ïò§ÎäòÏùò ÌôúÎèô ÏöîÏïΩ' } }]
              }
            });
            
            children.push({
              object: 'block',
              type: 'paragraph',
              paragraph: {
                rich_text: [{ type: 'text', text: { content: content } }]
              }
            });

            // ÏôÑÎ£åÎêú Ïù¥Ïäà
            if (categorized.completed.length > 0) {
              children.push({
                object: 'block',
                type: 'heading_2',
                heading_2: {
                  rich_text: [{ type: 'text', text: { content: `‚úÖ ÏôÑÎ£åÎêú Ïù¥Ïäà (${categorized.completed.length}Í±¥)` } }]
                }
              });

              for (const issue of categorized.completed) {
                children.push({
                  object: 'block',
                  type: 'bulleted_list_item',
                  bulleted_list_item: {
                    rich_text: [
                      { type: 'text', text: { content: `[#${issue.number}] ${issue.title} - `, link: null } },
                      { type: 'text', text: { content: 'Î∞îÎ°úÍ∞ÄÍ∏∞', link: { url: issue.html_url } } }
                    ]
                  }
                });
              }
            }

            // ÏÉàÎ°ú ÏÉùÏÑ±Îêú Ïù¥Ïäà
            if (categorized.new.length > 0) {
              children.push({
                object: 'block',
                type: 'heading_2',
                heading_2: {
                  rich_text: [{ type: 'text', text: { content: `üÜï ÏÉàÎ°ú ÏÉùÏÑ±Îêú Ïù¥Ïäà (${categorized.new.length}Í±¥)` } }]
                }
              });

              for (const issue of categorized.new) {
                children.push({
                  object: 'block',
                  type: 'bulleted_list_item',
                  bulleted_list_item: {
                    rich_text: [
                      { type: 'text', text: { content: `[#${issue.number}] ${issue.title} - `, link: null } },
                      { type: 'text', text: { content: 'Î∞îÎ°úÍ∞ÄÍ∏∞', link: { url: issue.html_url } } }
                    ]
                  }
                });
              }
            }

            // ÏóÖÎç∞Ïù¥Ìä∏Îêú Ïù¥Ïäà
            if (categorized.updated.length > 0) {
              children.push({
                object: 'block',
                type: 'heading_2',
                heading_2: {
                  rich_text: [{ type: 'text', text: { content: `üîÑ ÏßÑÌñâ Ï§ëÏù∏ Ïù¥Ïäà ÏóÖÎç∞Ïù¥Ìä∏ (${categorized.updated.length}Í±¥)` } }]
                }
              });

              for (const issue of categorized.updated) {
                children.push({
                  object: 'block',
                  type: 'bulleted_list_item',
                  bulleted_list_item: {
                    rich_text: [
                      { type: 'text', text: { content: `[#${issue.number}] ${issue.title} - `, link: null } },
                      { type: 'text', text: { content: 'Î∞îÎ°úÍ∞ÄÍ∏∞', link: { url: issue.html_url } } }
                    ]
                  }
                });
              }
            }

            // ÌôúÎ∞úÌïú ÎÖºÏùò
            if (categorized.discussed.length > 0) {
              children.push({
                object: 'block',
                type: 'heading_2',
                heading_2: {
                  rich_text: [{ type: 'text', text: { content: `üí¨ ÌôúÎ∞úÌïú ÎÖºÏùò (${categorized.discussed.length}Í±¥)` } }]
                }
              });

              for (const issue of categorized.discussed) {
                children.push({
                  object: 'block',
                  type: 'bulleted_list_item',
                  bulleted_list_item: {
                    rich_text: [
                      { type: 'text', text: { content: `[#${issue.number}] ${issue.title} (ÎåìÍ∏Ä ${issue.recent_comments_count}Í∞ú) - `, link: null } },
                      { type: 'text', text: { content: 'Î∞îÎ°úÍ∞ÄÍ∏∞', link: { url: issue.html_url } } }
                    ]
                  }
                });
              }
            }

            // Notion API Ìò∏Ï∂ú
            const options = {
              hostname: 'api.notion.com',
              path: '/v1/pages',
              method: 'POST',
              headers: {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json',
                'Notion-Version': '2022-06-28'
              }
            };

            const requestBody = JSON.stringify({
              parent: { type: 'workspace' },
              properties: {
                title: {
                  title: [{ type: 'text', text: { content: title } }]
                }
              },
              children: children
            });

            try {
              const response = await makeRequest(options, requestBody);
              return response;
            } catch (error) {
              console.error('Notion API Error:', error);
              throw error;
            }
          }

          // ========== Main Function ==========

          async function main() {
            console.log('üöÄ ÏùºÍ∞ÑÎ≥¥Í≥† ÏÉùÏÑ± ÏãúÏûë...\n');

            const owner = process.env.REPO_OWNER;
            const repo = process.env.REPO_NAME;
            const token = process.env.GITHUB_TOKEN;

            console.log(`üìÅ Repository: ${owner}/${repo}`);
            console.log(`üìÖ ÎÇ†Ïßú: ${formatDateForTitle()}\n`);

            // 1. GitHub Ïù¥Ïäà Ï°∞Ìöå
            console.log('1Ô∏è‚É£ GitHub Ïù¥Ïäà Ï°∞Ìöå Ï§ë...');
            const issues = await fetchIssuesWithActivity(owner, repo, token);
            console.log(`   ‚úÖ Ï¥ù ${issues.length}Í∞úÏùò ÌôúÎèôÎêú Ïù¥Ïäà Î∞úÍ≤¨\n`);

            // 2. Ïù¥Ïäà Î∂ÑÎ•ò
            console.log('2Ô∏è‚É£ Ïù¥Ïäà Î∂ÑÎ•ò Ï§ë...');
            const categorized = await categorizeIssues(issues, owner, repo, token);
            console.log(`   ‚úÖ ÏôÑÎ£å: ${categorized.completed.length}Í±¥`);
            console.log(`   ‚úÖ Ïã†Í∑ú: ${categorized.new.length}Í±¥`);
            console.log(`   ‚úÖ ÏóÖÎç∞Ïù¥Ìä∏: ${categorized.updated.length}Í±¥`);
            console.log(`   ‚úÖ ÎÖºÏùò: ${categorized.discussed.length}Í±¥\n`);

            // 3. GeminiÎ°ú ÏöîÏïΩ ÏÉùÏÑ±
            console.log('3Ô∏è‚É£ AI ÏöîÏïΩ ÏÉùÏÑ± Ï§ë...');
            const summary = await generateSummaryWithGemini(categorized);
            console.log(`   ‚úÖ ÏöîÏïΩ ÏÉùÏÑ± ÏôÑÎ£å\n`);

            // 4. Notion ÌéòÏù¥ÏßÄ ÏÉùÏÑ±
            console.log('4Ô∏è‚É£ Notion ÌéòÏù¥ÏßÄ ÏÉùÏÑ± Ï§ë...');
            const title = `${formatDateForTitle()} ÏùºÍ∞ÑÎ≥¥Í≥†`;
            const repoUrl = `https://github.com/${owner}/${repo}`;
            
            const page = await createNotionPage(title, summary, categorized, repoUrl);
            console.log(`   ‚úÖ Notion ÌéòÏù¥ÏßÄ ÏÉùÏÑ± ÏôÑÎ£å`);
            console.log(`   üìÑ ÌéòÏù¥ÏßÄ ID: ${page.id}`);
            console.log(`   üîó URL: ${page.url}\n`);

            console.log('‚ú® ÏùºÍ∞ÑÎ≥¥Í≥† ÏÉùÏÑ± ÏôÑÎ£å!');
          }

          main().catch(error => {
            console.error('‚ùå Error:', error);
            process.exit(1);
          });
          EOF

      - name: Generate daily report
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          NOTION_TOKEN: ${{ secrets.NOTION_TOKEN }}
          REPO_OWNER: ${{ github.repository_owner }}
          REPO_NAME: ${{ github.event.repository.name }}
        run: node daily-report.js
