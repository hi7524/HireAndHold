name: Daily Report to Notion

on:
  schedule:
    - cron: '0 0 * * *'
  workflow_dispatch:

jobs:
  generate-daily-report:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Create and run daily report script
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          NOTION_TOKEN: ${{ secrets.NOTION_TOKEN }}
          REPO_OWNER: ${{ github.repository_owner }}
          REPO_NAME: ${{ github.event.repository.name }}
        run: |
          node << 'NODESCRIPT'
          const https = require('https');

          async function makeRequest(options, postData) {
            return new Promise((resolve, reject) => {
              const req = https.request(options, (res) => {
                let data = '';
                res.on('data', (chunk) => data += chunk);
                res.on('end', () => {
                  try {
                    resolve(JSON.parse(data));
                  } catch (e) {
                    resolve(data);
                  }
                });
              });
              req.on('error', reject);
              if (postData) req.write(postData);
              req.end();
            });
          }

          function formatDateForTitle() {
            const now = new Date();
            const kst = new Date(now.getTime() + (9 * 60 * 60 * 1000));
            const yy = String(kst.getFullYear()).slice(2);
            const mm = String(kst.getMonth() + 1).padStart(2, '0');
            const dd = String(kst.getDate()).padStart(2, '0');
            return yy + '.' + mm + '.' + dd;
          }

          function get24HoursAgo() {
            const now = new Date();
            const yesterday = new Date(now.getTime() - (24 * 60 * 60 * 1000));
            return yesterday.toISOString();
          }

          async function fetchIssuesWithActivity(owner, repo, token) {
            const since = get24HoursAgo();
            const options = {
              hostname: 'api.github.com',
              path: '/repos/' + owner + '/' + repo + '/issues?state=all&since=' + since + '&per_page=100',
              method: 'GET',
              headers: {
                'User-Agent': 'GitHub-Actions',
                'Authorization': 'token ' + token,
                'Accept': 'application/vnd.github.v3+json'
              }
            };
            const issues = await makeRequest(options);
            return issues.filter(issue => !issue.pull_request);
          }

          async function fetchIssueComments(owner, repo, issueNumber, token) {
            const since = get24HoursAgo();
            const options = {
              hostname: 'api.github.com',
              path: '/repos/' + owner + '/' + repo + '/issues/' + issueNumber + '/comments?since=' + since,
              method: 'GET',
              headers: {
                'User-Agent': 'GitHub-Actions',
                'Authorization': 'token ' + token,
                'Accept': 'application/vnd.github.v3+json'
              }
            };
            return await makeRequest(options);
          }

          async function categorizeIssues(issues, owner, repo, token) {
            const since = new Date(get24HoursAgo());
            const categorized = {
              completed: [],
              new: [],
              updated: [],
              discussed: []
            };

            for (const issue of issues) {
              const createdAt = new Date(issue.created_at);
              const updatedAt = new Date(issue.updated_at);
              const closedAt = issue.closed_at ? new Date(issue.closed_at) : null;

              if (issue.state === 'closed' && closedAt && closedAt > since) {
                categorized.completed.push(issue);
              } else if (createdAt > since) {
                categorized.new.push(issue);
              } else if (updatedAt > since && issue.state === 'open') {
                const comments = await fetchIssueComments(owner, repo, issue.number, token);
                if (comments.length > 0) {
                  categorized.discussed.push({...issue, recent_comments_count: comments.length});
                } else {
                  categorized.updated.push(issue);
                }
              }
            }
            return categorized;
          }

          async function generateSummaryWithGemini(categorized) {
            const apiKey = process.env.GEMINI_API_KEY;
            let prompt = "Îã§ÏùåÏùÄ GitHub ÌîÑÎ°úÏ†ùÌä∏Ïùò ÏßÄÎÇú 24ÏãúÍ∞Ñ ÎèôÏïàÏùò ÌôúÎèô ÎÇ¥Ïó≠ÏûÖÎãàÎã§. ";
            prompt += "Ï†ÑÏ≤¥Ï†ÅÏù∏ ÏßÑÌñâ ÏÉÅÌô©ÏùÑ 3-4Î¨∏Îã®ÏúºÎ°ú ÏöîÏïΩÌï¥Ï£ºÏÑ∏Ïöî.";
            prompt += "\n\nÏôÑÎ£å: " + categorized.completed.length;
            prompt += "\nÏã†Í∑ú: " + categorized.new.length;
            prompt += "\nÏóÖÎç∞Ïù¥Ìä∏: " + categorized.updated.length;
            prompt += "\nÎÖºÏùò: " + categorized.discussed.length;

            const options = {
              hostname: 'generativelanguage.googleapis.com',
              path: '/v1beta/models/gemini-pro:generateContent?key=' + apiKey,
              method: 'POST',
              headers: {'Content-Type': 'application/json'}
            };

            try {
              const response = await makeRequest(options, JSON.stringify({
                contents: [{parts: [{text: prompt}]}]
              }));
              if (response.candidates && response.candidates[0]) {
                return response.candidates[0].content.parts[0].text.trim();
              }
              return 'Ïò§ÎäòÏùò ÌôúÎèôÏùÑ ÏöîÏïΩÌï† Ïàò ÏóÜÏäµÎãàÎã§.';
            } catch (error) {
              console.error('Gemini API Error:', error);
              return 'ÏöîÏïΩ ÏÉùÏÑ± Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.';
            }
          }

          async function createNotionPage(title, content, categorized) {
            const token = process.env.NOTION_TOKEN;
            const children = [];
            
            children.push({
              object: 'block',
              type: 'heading_2',
              heading_2: {rich_text: [{type: 'text', text: {content: 'üìä Ïò§ÎäòÏùò ÌôúÎèô ÏöîÏïΩ'}}]}
            });
            children.push({
              object: 'block',
              type: 'paragraph',
              paragraph: {rich_text: [{type: 'text', text: {content: content}}]}
            });

            if (categorized.completed.length > 0) {
              children.push({
                object: 'block',
                type: 'heading_2',
                heading_2: {rich_text: [{type: 'text', text: {content: '‚úÖ ÏôÑÎ£å (' + categorized.completed.length + 'Í±¥)'}}]}
              });
              for (const issue of categorized.completed) {
                children.push({
                  object: 'block',
                  type: 'bulleted_list_item',
                  bulleted_list_item: {
                    rich_text: [
                      {type: 'text', text: {content: '[#' + issue.number + '] ' + issue.title + ' - '}},
                      {type: 'text', text: {content: 'Î∞îÎ°úÍ∞ÄÍ∏∞'}, link: {url: issue.html_url}}
                    ]
                  }
                });
              }
            }

            if (categorized.new.length > 0) {
              children.push({
                object: 'block',
                type: 'heading_2',
                heading_2: {rich_text: [{type: 'text', text: {content: 'üÜï Ïã†Í∑ú (' + categorized.new.length + 'Í±¥)'}}]}
              });
              for (const issue of categorized.new) {
                children.push({
                  object: 'block',
                  type: 'bulleted_list_item',
                  bulleted_list_item: {
                    rich_text: [
                      {type: 'text', text: {content: '[#' + issue.number + '] ' + issue.title + ' - '}},
                      {type: 'text', text: {content: 'Î∞îÎ°úÍ∞ÄÍ∏∞'}, link: {url: issue.html_url}}
                    ]
                  }
                });
              }
            }

            const options = {
              hostname: 'api.notion.com',
              path: '/v1/pages',
              method: 'POST',
              headers: {
                'Authorization': 'Bearer ' + token,
                'Content-Type': 'application/json',
                'Notion-Version': '2022-06-28'
              }
            };

            const requestBody = JSON.stringify({
              parent: {type: 'workspace'},
              properties: {title: {title: [{type: 'text', text: {content: title}}]}},
              children: children
            });

            try {
              const response = await makeRequest(options, requestBody);
              return response;
            } catch (error) {
              console.error('Notion API Error:', error);
              throw error;
            }
          }

          async function main() {
            console.log('üöÄ ÏùºÍ∞ÑÎ≥¥Í≥† ÏÉùÏÑ± ÏãúÏûë');
            const owner = process.env.REPO_OWNER;
            const repo = process.env.REPO_NAME;
            const token = process.env.GITHUB_TOKEN;

            const issues = await fetchIssuesWithActivity(owner, repo, token);
            console.log('‚úÖ Ïù¥Ïäà Ï°∞Ìöå: ' + issues.length + 'Í±¥');

            const categorized = await categorizeIssues(issues, owner, repo, token);
            console.log('‚úÖ ÏôÑÎ£å:' + categorized.completed.length + ' Ïã†Í∑ú:' + categorized.new.length);

            const summary = await generateSummaryWithGemini(categorized);
            console.log('‚úÖ AI ÏöîÏïΩ ÏôÑÎ£å');

            const title = formatDateForTitle() + ' ÏùºÍ∞ÑÎ≥¥Í≥†';
            const page = await createNotionPage(title, summary, categorized);
            console.log('‚úÖ Notion ÌéòÏù¥ÏßÄ: ' + page.url);
            console.log('‚ú® ÏôÑÎ£å!');
          }

          main().catch(error => {
            console.error('‚ùå Error:', error);
            process.exit(1);
          });
          NODESCRIPT
