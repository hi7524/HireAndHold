name: Daily Report to Notion

on:
  schedule:
    - cron: '0 0 * * *'
  workflow_dispatch:

jobs:
  generate-daily-report:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Create daily report script
        run: |
          cat > daily-report.js << 'SCRIPTEOF'
          const https = require('https');

          async function makeRequest(options, postData) {
            return new Promise((resolve, reject) => {
              const req = https.request(options, (res) => {
                let data = '';
                res.on('data', (chunk) => data += chunk);
                res.on('end', () => {
                  try {
                    resolve(JSON.parse(data));
                  } catch (e) {
                    resolve(data);
                  }
                });
              });
              req.on('error', reject);
              if (postData) req.write(postData);
              req.end();
            });
          }

          function getKSTDate() {
            const now = new Date();
            const kst = new Date(now.getTime() + (9 * 60 * 60 * 1000));
            return kst;
          }

          function formatDateForTitle() {
            const date = getKSTDate();
            const yy = String(date.getFullYear()).slice(2);
            const mm = String(date.getMonth() + 1).padStart(2, '0');
            const dd = String(date.getDate()).padStart(2, '0');
            return yy + '.' + mm + '.' + dd;
          }

          function get24HoursAgo() {
            const now = new Date();
            const yesterday = new Date(now.getTime() - (24 * 60 * 60 * 1000));
            return yesterday.toISOString();
          }

          async function fetchIssuesWithActivity(owner, repo, token) {
            const since = get24HoursAgo();
            
            const options = {
              hostname: 'api.github.com',
              path: '/repos/' + owner + '/' + repo + '/issues?state=all&since=' + since + '&per_page=100',
              method: 'GET',
              headers: {
                'User-Agent': 'GitHub-Actions',
                'Authorization': 'token ' + token,
                'Accept': 'application/vnd.github.v3+json'
              }
            };

            const issues = await makeRequest(options);
            return issues.filter(issue => !issue.pull_request);
          }

          async function fetchIssueComments(owner, repo, issueNumber, token) {
            const since = get24HoursAgo();
            
            const options = {
              hostname: 'api.github.com',
              path: '/repos/' + owner + '/' + repo + '/issues/' + issueNumber + '/comments?since=' + since,
              method: 'GET',
              headers: {
                'User-Agent': 'GitHub-Actions',
                'Authorization': 'token ' + token,
                'Accept': 'application/vnd.github.v3+json'
              }
            };

            return await makeRequest(options);
          }

          async function categorizeIssues(issues, owner, repo, token) {
            const since = new Date(get24HoursAgo());
            
            const categorized = {
              completed: [],
              new: [],
              updated: [],
              discussed: []
            };

            for (const issue of issues) {
              const createdAt = new Date(issue.created_at);
              const updatedAt = new Date(issue.updated_at);
              const closedAt = issue.closed_at ? new Date(issue.closed_at) : null;

              if (issue.state === 'closed' && closedAt && closedAt > since) {
                categorized.completed.push(issue);
              }
              else if (createdAt > since) {
                categorized.new.push(issue);
              }
              else if (updatedAt > since && issue.state === 'open') {
                const comments = await fetchIssueComments(owner, repo, issue.number, token);
                
                if (comments.length > 0) {
                  categorized.discussed.push({
                    ...issue,
                    recent_comments_count: comments.length
                  });
                } else {
                  categorized.updated.push(issue);
                }
              }
            }

            return categorized;
          }

          async function generateSummaryWithGemini(categorized) {
            const apiKey = process.env.GEMINI_API_KEY;
            
            let prompt = "Îã§ÏùåÏùÄ GitHub ÌîÑÎ°úÏ†ùÌä∏Ïùò ÏßÄÎÇú 24ÏãúÍ∞Ñ ÎèôÏïàÏùò ÌôúÎèô ÎÇ¥Ïó≠ÏûÖÎãàÎã§. ";
            prompt += "Ï†ÑÏ≤¥Ï†ÅÏù∏ ÏßÑÌñâ ÏÉÅÌô©ÏùÑ 3-4Î¨∏Îã®ÏúºÎ°ú ÏöîÏïΩÌï¥Ï£ºÏÑ∏Ïöî. ÏôÑÎ£åÎêú ÏûëÏóÖ, ÏÉàÎ°úÏö¥ Ïù¥Ïäà, ÏßÑÌñâ Ï§ëÏù∏ ÏûëÏóÖÏùÑ Ï§ëÏã¨ÏúºÎ°ú ÏûëÏÑ±Ìï¥Ï£ºÏÑ∏Ïöî.\n\n";
            
            prompt += "## ÏôÑÎ£åÎêú Ïù¥Ïäà (" + categorized.completed.length + "Í±¥)\n";
            prompt += categorized.completed.map(issue => "- [#" + issue.number + "] " + issue.title).join("\n") + "\n\n";
            
            prompt += "## ÏÉàÎ°ú ÏÉùÏÑ±Îêú Ïù¥Ïäà (" + categorized.new.length + "Í±¥)\n";
            prompt += categorized.new.map(issue => "- [#" + issue.number + "] " + issue.title).join("\n") + "\n\n";
            
            prompt += "## ÏóÖÎç∞Ïù¥Ìä∏Îêú Ïù¥Ïäà (" + categorized.updated.length + "Í±¥)\n";
            prompt += categorized.updated.map(issue => "- [#" + issue.number + "] " + issue.title).join("\n") + "\n\n";
            
            prompt += "## ÌôúÎ∞úÌïú ÎÖºÏùò (" + categorized.discussed.length + "Í±¥)\n";
            prompt += categorized.discussed.map(issue => "- [#" + issue.number + "] " + issue.title + " (ÎåìÍ∏Ä " + issue.recent_comments_count + "Í∞ú)").join("\n") + "\n\n";
            
            prompt += "ÏöîÏïΩ:";

            const options = {
              hostname: 'generativelanguage.googleapis.com',
              path: '/v1beta/models/gemini-pro:generateContent?key=' + apiKey,
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              }
            };

            const requestBody = JSON.stringify({
              contents: [{
                parts: [{
                  text: prompt
                }]
              }]
            });

            try {
              const response = await makeRequest(options, requestBody);
              
              if (response.candidates && response.candidates[0]) {
                return response.candidates[0].content.parts[0].text.trim();
              }
              
              return 'Ïò§ÎäòÏùò ÌôúÎèôÏùÑ ÏöîÏïΩÌï† Ïàò ÏóÜÏäµÎãàÎã§.';
            } catch (error) {
              console.error('Gemini API Error:', error);
              return 'ÏöîÏïΩ ÏÉùÏÑ± Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.';
            }
          }

          async function createNotionPage(title, content, categorized) {
            const token = process.env.NOTION_TOKEN;
            
            const children = [];
            
            children.push({
              object: 'block',
              type: 'heading_2',
              heading_2: {
                rich_text: [{ type: 'text', text: { content: 'üìä Ïò§ÎäòÏùò ÌôúÎèô ÏöîÏïΩ' } }]
              }
            });
            
            children.push({
              object: 'block',
              type: 'paragraph',
              paragraph: {
                rich_text: [{ type: 'text', text: { content: content } }]
              }
            });

            if (categorized.completed.length > 0) {
              children.push({
                object: 'block',
                type: 'heading_2',
                heading_2: {
                  rich_text: [{ type: 'text', text: { content: '‚úÖ ÏôÑÎ£åÎêú Ïù¥Ïäà (' + categorized.completed.length + 'Í±¥)' } }]
                }
              });

              for (const issue of categorized.completed) {
                children.push({
                  object: 'block',
                  type: 'bulleted_list_item',
                  bulleted_list_item: {
                    rich_text: [
                      { type: 'text', text: { content: '[#' + issue.number + '] ' + issue.title + ' - ' } },
                      { type: 'text', text: { content: 'Î∞îÎ°úÍ∞ÄÍ∏∞' }, link: { url: issue.html_url } }
                    ]
                  }
                });
              }
            }

            if (categorized.new.length > 0) {
              children.push({
                object: 'block',
                type: 'heading_2',
                heading_2: {
                  rich_text: [{ type: 'text', text: { content: 'üÜï ÏÉàÎ°ú ÏÉùÏÑ±Îêú Ïù¥Ïäà (' + categorized.new.length + 'Í±¥)' } }]
                }
              });

              for (const issue of categorized.new) {
                children.push({
                  object: 'block',
                  type: 'bulleted_list_item',
                  bulleted_list_item: {
                    rich_text: [
                      { type: 'text', text: { content: '[#' + issue.number + '] ' + issue.title + ' - ' } },
                      { type: 'text', text: { content: 'Î∞îÎ°úÍ∞ÄÍ∏∞' }, link: { url: issue.html_url } }
                    ]
                  }
                });
              }
            }

            if (categorized.updated.length > 0) {
              children.push({
                object: 'block',
                type: 'heading_2',
                heading_2: {
                  rich_text: [{ type: 'text', text: { content: 'üîÑ ÏßÑÌñâ Ï§ëÏù∏ Ïù¥Ïäà ÏóÖÎç∞Ïù¥Ìä∏ (' + categorized.updated.length + 'Í±¥)' } }]
                }
              });

              for (const issue of categorized.updated) {
                children.push({
                  object: 'block',\n                  type: 'bulleted_list_item',
                  bulleted_list_item: {
                    rich_text: [
                      { type: 'text', text: { content: '[#' + issue.number + '] ' + issue.title + ' - ' } },
                      { type: 'text', text: { content: 'Î∞îÎ°úÍ∞ÄÍ∏∞' }, link: { url: issue.html_url } }
                    ]
                  }
                });
              }
            }

            if (categorized.discussed.length > 0) {
              children.push({
                object: 'block',
                type: 'heading_2',
                heading_2: {
                  rich_text: [{ type: 'text', text: { content: 'üí¨ ÌôúÎ∞úÌïú ÎÖºÏùò (' + categorized.discussed.length + 'Í±¥)' } }]
                }
              });

              for (const issue of categorized.discussed) {
                children.push({
                  object: 'block',
                  type: 'bulleted_list_item',
                  bulleted_list_item: {
                    rich_text: [
                      { type: 'text', text: { content: '[#' + issue.number + '] ' + issue.title + ' (ÎåìÍ∏Ä ' + issue.recent_comments_count + 'Í∞ú) - ' } },
                      { type: 'text', text: { content: 'Î∞îÎ°úÍ∞ÄÍ∏∞' }, link: { url: issue.html_url } }
                    ]
                  }
                });
              }
            }

            const options = {
              hostname: 'api.notion.com',
              path: '/v1/pages',
              method: 'POST',
              headers: {
                'Authorization': 'Bearer ' + token,
                'Content-Type': 'application/json',
                'Notion-Version': '2022-06-28'
              }
            };

            const requestBody = JSON.stringify({
              parent: { type: 'workspace' },
              properties: {
                title: {
                  title: [{ type: 'text', text: { content: title } }]
                }
              },
              children: children
            });

            try {
              const response = await makeRequest(options, requestBody);
              return response;
            } catch (error) {
              console.error('Notion API Error:', error);
              throw error;
            }
          }

          async function main() {
            console.log('üöÄ ÏùºÍ∞ÑÎ≥¥Í≥† ÏÉùÏÑ± ÏãúÏûë...\n');

            const owner = process.env.REPO_OWNER;
            const repo = process.env.REPO_NAME;
            const token = process.env.GITHUB_TOKEN;

            console.log('üìÅ Repository: ' + owner + '/' + repo);
            console.log('üìÖ ÎÇ†Ïßú: ' + formatDateForTitle() + '\n');

            console.log('1Ô∏è‚É£ GitHub Ïù¥Ïäà Ï°∞Ìöå Ï§ë...');
            const issues = await fetchIssuesWithActivity(owner, repo, token);
            console.log('   ‚úÖ Ï¥ù ' + issues.length + 'Í∞úÏùò ÌôúÎèôÎêú Ïù¥Ïäà Î∞úÍ≤¨\n');

            console.log('2Ô∏è‚É£ Ïù¥Ïäà Î∂ÑÎ•ò Ï§ë...');
            const categorized = await categorizeIssues(issues, owner, repo, token);
            console.log('   ‚úÖ ÏôÑÎ£å: ' + categorized.completed.length + 'Í±¥');
            console.log('   ‚úÖ Ïã†Í∑ú: ' + categorized.new.length + 'Í±¥');
            console.log('   ‚úÖ ÏóÖÎç∞Ïù¥Ìä∏: ' + categorized.updated.length + 'Í±¥');
            console.log('   ‚úÖ ÎÖºÏùò: ' + categorized.discussed.length + 'Í±¥\n');

            console.log('3Ô∏è‚É£ AI ÏöîÏïΩ ÏÉùÏÑ± Ï§ë...');
            const summary = await generateSummaryWithGemini(categorized);
            console.log('   ‚úÖ ÏöîÏïΩ ÏÉùÏÑ± ÏôÑÎ£å\n');

            console.log('4Ô∏è‚É£ Notion ÌéòÏù¥ÏßÄ ÏÉùÏÑ± Ï§ë...');
            const title = formatDateForTitle() + ' ÏùºÍ∞ÑÎ≥¥Í≥†';
            
            const page = await createNotionPage(title, summary, categorized);
            console.log('   ‚úÖ Notion ÌéòÏù¥ÏßÄ ÏÉùÏÑ± ÏôÑÎ£å');
            console.log('   üìÑ ÌéòÏù¥ÏßÄ ID: ' + page.id);
            console.log('   üîó URL: ' + page.url + '\n');

            console.log('‚ú® ÏùºÍ∞ÑÎ≥¥Í≥† ÏÉùÏÑ± ÏôÑÎ£å!');
          }

          main().catch(error => {
            console.error('‚ùå Error:', error);
            process.exit(1);
          });
          SCRIPTEOF

      - name: Generate daily report
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          NOTION_TOKEN: ${{ secrets.NOTION_TOKEN }}
          REPO_OWNER: ${{ github.repository_owner }}
          REPO_NAME: ${{ github.event.repository.name }}
        run: node daily-report.js
